<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rundholz-Volumenrechner</title>
    <!-- Tailwind CSS laden -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Zusätzliche, spezifische Stile für bessere Ästhetik */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc; /* Leichter grauer Hintergrund */
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4 bg-gray-100">

    <div id="app" class="w-full max-w-lg bg-white shadow-xl rounded-xl p-8 space-y-6">
        <h1 class="text-3xl font-bold text-center text-green-700">Rundholz-Volumenrechner</h1>
        <p class="text-center text-gray-500">Berechnen Sie das Volumen nach der Mitteldurchmesser-Methode (Formel nach Huber).</p>

        <!-- Eingabefelder -->
        <div class="space-y-4">
            <!-- Länge des Stammes -->
            <div>
                <label for="length" class="block text-sm font-medium text-gray-700 mb-1">Länge des Stammes (L in Meter)</label>
                <input type="number" id="length" value="4.0" step="0.1" min="0.1"
                       class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-150"
                       placeholder="z.B. 4.0">
            </div>

            <!-- Mittendurchmesser -->
            <div>
                <label for="diameter" class="block text-sm font-medium text-gray-700 mb-1">Mittendurchmesser (d in Zentimeter)</label>
                <input type="number" id="diameter" value="30" step="1" min="1"
                       class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-150"
                       placeholder="z.B. 30">
                <p class="text-xs text-gray-400 mt-1">Der Durchmesser wird in der Mitte des Stammes gemessen (ohne Rinde).</p>
            </div>
        </div>

        <!-- Berechnung Button -->
        <button onclick="calculateVolume()"
                class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 rounded-lg shadow-md transition duration-200 transform hover:scale-[1.01] focus:outline-none focus:ring-4 focus:ring-green-500 focus:ring-opacity-50">
            Volumen berechnen
        </button>

        <!-- Ergebnisbereich -->
        <div id="result-box" class="mt-6 p-4 border border-green-300 bg-green-50 rounded-lg text-center hidden">
            <p class="text-lg font-medium text-green-800">
                Ergebnis (Volumen V): <span id="volume-output" class="text-2xl font-bold">0.000 m³</span>
            </p>
        </div>

        <!-- Fehlermeldung -->
        <div id="error-message" class="mt-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg hidden">
            Bitte geben Sie gültige Werte (größer als Null) für Länge und Durchmesser ein.
        </div>
    </div>

    <script>
        // Funktion zur Umwandlung von Base64 zu ArrayBuffer für TTS (Notwendige Helper-Funktionen)
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Funktion zur Erstellung eines WAV-Containers aus PCM-Daten
        function pcmToWav(pcm16, sampleRate = 16000) {
            const numChannels = 1;
            const bytesPerSample = 2; // Int16
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataLength = pcm16.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);

            let offset = 0;

            // RIFF chunk
            function writeString(str) {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset++, str.charCodeAt(i));
                }
            }
            writeString('RIFF');
            view.setUint32(offset, 36 + dataLength, true); offset += 4;
            writeString('WAVE');

            // FMT chunk
            writeString('fmt ');
            view.setUint32(offset, 16, true); offset += 4; // Sub-chunk size
            view.setUint16(offset, 1, true); offset += 2; // Audio format (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2; // Num channels
            view.setUint32(offset, sampleRate, true); offset += 4; // Sample rate
            view.setUint32(offset, byteRate, true); offset += 4; // Byte rate
            view.setUint16(offset, blockAlign, true); offset += 2; // Block align
            view.setUint16(offset, 16, true); offset += 2; // Bits per sample (16)

            // DATA chunk
            writeString('data');
            view.setUint32(offset, dataLength, true); offset += 4;
            
            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }

            return new Blob([view], { type: 'audio/wav' });
        }


        /**
         * Berechnet das Rundholzvolumen nach der Huber-Formel.
         * V = π/4 * (d_mitte/100)^2 * L
         * wobei d_mitte in cm und L in m eingegeben wird.
         * Ergebnis ist in Kubikmetern (m³).
         */
        function calculateVolume() {
            const lengthInput = document.getElementById('length');
            const diameterInput = document.getElementById('diameter');
            const volumeOutput = document.getElementById('volume-output');
            const resultBox = document.getElementById('result-box');
            const errorMessage = document.getElementById('error-message');

            // Eingabewerte holen und in Zahlen umwandeln
            const L = parseFloat(lengthInput.value); // Länge in Metern
            const d_cm = parseFloat(diameterInput.value); // Durchmesser in Zentimetern

            // Validierung
            if (isNaN(L) || isNaN(d_cm) || L <= 0 || d_cm <= 0) {
                resultBox.classList.add('hidden');
                errorMessage.classList.remove('hidden');
                return;
            }

            // Durchmesser von cm in m umrechnen: d_m = d_cm / 100
            const d_m = d_cm / 100;

            // Formel nach Huber: V = (Pi / 4) * d^2 * L
            const V = (Math.PI / 4) * Math.pow(d_m, 2) * L;

            // Auf 3 Dezimalstellen runden
            const roundedVolume = V.toFixed(3);

            // Ergebnis anzeigen
            volumeOutput.textContent = `${roundedVolume} m³`;
            resultBox.classList.remove('hidden');
            errorMessage.classList.add('hidden');

            // Optional: Ergebnis vorlesen lassen (nur als Beispiel)
            speakResult(roundedVolume);
        }

        /**
         * Liest das Ergebnis mit der TTS-API vor.
         * @param {string} volume Volumenwert als String.
         */
        async function speakResult(volume) {
            const textToSpeak = `Das berechnete Volumen beträgt ${volume} Kubikmeter.`;
            const apiKey = ""; // API-Schlüssel wird zur Laufzeit bereitgestellt
            const apiUrl = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=" + apiKey;

            const payload = {
                contents: [{
                    parts: [{ text: textToSpeak }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Charon" }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            // Versuche mit Exponential Backoff (1s, 2s, 4s, ...)
            const maxRetries = 5;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        // Der API-Antwort-MimeType enthält die Sample Rate, z.B. "audio/L16;rate=16000"
                        const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000;
                        
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        
                        // Konvertiere die PCM-Daten in ein abspielbares WAV-Blob
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        
                        const audio = new Audio(audioUrl);
                        audio.play();
                        
                        return; // Erfolg, Schleife beenden
                    } else {
                        throw new Error("TTS response missing audio data.");
                    }
                } catch (error) {
                    console.error(`Attempt ${attempt + 1} failed:`, error);
                    if (attempt < maxRetries - 1) {
                        const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s, ...
                        await new Promise(res => setTimeout(res, delay));
                    }
                }
            }
            console.error("TTS failed after maximum retries.");
        }
        
        // Stellt sicher, dass die Funktion beim Klick auf den Button aufrufbar ist
        window.calculateVolume = calculateVolume;
        
        // Erste Berechnung beim Laden ausführen, um Initialwerte anzuzeigen
        window.onload = calculateVolume; 
    </script>

</body>
</html>
